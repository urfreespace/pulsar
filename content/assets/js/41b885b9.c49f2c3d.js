"use strict";(self.webpackChunkwebsite_next=self.webpackChunkwebsite_next||[]).push([[22862],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return f}});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=a.createContext({}),l=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=l(e.components);return a.createElement(c.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=l(t),f=r,m=p["".concat(c,".").concat(f)]||p[f]||d[f]||o;return t?a.createElement(m,i(i({ref:n},u),{},{components:t})):a.createElement(m,i({ref:n},u))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=p;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=t[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},58215:function(e,n,t){var a=t(67294);n.Z=function(e){var n=e.children,t=e.hidden,r=e.className;return a.createElement("div",{role:"tabpanel",hidden:t,className:r},n)}},26396:function(e,n,t){t.d(n,{Z:function(){return p}});var a=t(87462),r=t(67294),o=t(72389),i=t(79443);var s=function(){var e=(0,r.useContext)(i.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},c=t(89521),l=t(86010),u="tabItem_vU9c";function d(e){var n,t,a,o=e.lazy,i=e.block,d=e.defaultValue,p=e.values,f=e.groupId,m=e.className,h=r.Children.map(e.children,(function(e){if((0,r.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),v=null!=p?p:h.map((function(e){var n=e.props;return{value:n.value,label:n.label}})),b=(0,c.lx)(v,(function(e,n){return e.value===n.value}));if(b.length>0)throw new Error('Docusaurus error: Duplicate values "'+b.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var g=null===d?d:null!=(n=null!=d?d:null==(t=h.find((function(e){return e.props.default})))?void 0:t.props.value)?n:null==(a=h[0])?void 0:a.props.value;if(null!==g&&!v.some((function(e){return e.value===g})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+g+'" but none of its children has the corresponding value. Available values are: '+v.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var w=s(),y=w.tabGroupChoices,k=w.setTabGroupChoices,T=(0,r.useState)(g),O=T[0],E=T[1],x=[],P=(0,c.o5)().blockElementScrollPositionUntilNextRender;if(null!=f){var D=y[f];null!=D&&D!==O&&v.some((function(e){return e.value===D}))&&E(D)}var I=function(e){var n=e.currentTarget,t=x.indexOf(n),a=v[t].value;a!==O&&(P(n),E(a),null!=f&&k(f,a))},j=function(e){var n,t=null;switch(e.key){case"ArrowRight":var a=x.indexOf(e.currentTarget)+1;t=x[a]||x[0];break;case"ArrowLeft":var r=x.indexOf(e.currentTarget)-1;t=x[r]||x[x.length-1]}null==(n=t)||n.focus()};return r.createElement("div",{className:"tabs-container"},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":i},m)},v.map((function(e){var n=e.value,t=e.label;return r.createElement("li",{role:"tab",tabIndex:O===n?0:-1,"aria-selected":O===n,className:(0,l.Z)("tabs__item",u,{"tabs__item--active":O===n}),key:n,ref:function(e){return x.push(e)},onKeyDown:j,onFocus:I,onClick:I},null!=t?t:n)}))),o?(0,r.cloneElement)(h.filter((function(e){return e.props.value===O}))[0],{className:"margin-vert--md"}):r.createElement("div",{className:"margin-vert--md"},h.map((function(e,n){return(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==O})}))))}function p(e){var n=(0,o.Z)();return r.createElement(d,(0,a.Z)({key:String(n)},e))}},79443:function(e,n,t){var a=(0,t(67294).createContext)(void 0);n.Z=a},58640:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return u},default:function(){return p}});var a=t(87462),r=t(63366),o=(t(67294),t(3905)),i=(t(26396),t(58215),["components"]),s={id:"transactions",title:"Transactions",sidebar_label:"Overview",original_id:"transactions"},c=void 0,l={unversionedId:"transactions",id:"version-2.7.0/transactions",isDocsHomePage:!1,title:"Transactions",description:"Transactional semantics enable event streaming applications to consume, process, and produce messages in one atomic operation. In Pulsar, a producer or consumer can work with messages across multiple topics and partitions and ensure those messages are processed as a single unit.",source:"@site/versioned_docs/version-2.7.0/concepts-transactions.md",sourceDirName:".",slug:"/transactions",permalink:"/docs/2.7.0/transactions",editUrl:"https://github.com/apache/pulsar/edit/master/site2/website-next/versioned_docs/version-2.7.0/concepts-transactions.md",tags:[],version:"2.7.0",frontMatter:{id:"transactions",title:"Transactions",sidebar_label:"Overview",original_id:"transactions"},sidebar:"version-2.7.0/docsSidebar",previous:{title:"Azure BlobStore offloader",permalink:"/docs/2.7.0/tiered-storage-azure"},next:{title:"Transactions Guarantee",permalink:"/docs/2.7.0/transactions-guarantee"}},u=[{value:"Transaction coordinator and transaction log",id:"transaction-coordinator-and-transaction-log",children:[],level:2},{value:"Transaction ID",id:"transaction-id",children:[],level:2},{value:"Transaction buffer",id:"transaction-buffer",children:[],level:2},{value:"Pending acknowledge state",id:"pending-acknowledge-state",children:[],level:2}],d={toc:u};function p(e){var n=e.components,t=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Transactional semantics enable event streaming applications to consume, process, and produce messages in one atomic operation. In Pulsar, a producer or consumer can work with messages across multiple topics and partitions and ensure those messages are processed as a single unit. "),(0,o.kt)("p",null,"The following concepts help you understand Pulsar transactions."),(0,o.kt)("h2",{id:"transaction-coordinator-and-transaction-log"},"Transaction coordinator and transaction log"),(0,o.kt)("p",null,"The transaction coordinator maintains the topics and subscriptions that interact in a transaction. When a transaction is committed, the transaction coordinator interacts with the topic owner broker to complete the transaction."),(0,o.kt)("p",null,"The transaction coordinator maintains the entire life cycle of transactions, and prevents a transaction from incorrect status."),(0,o.kt)("p",null,"The transaction coordinator handles transaction timeout, and ensures that the transaction is aborted after a transaction timeout."),(0,o.kt)("p",null,"All the transaction metadata is persisted in the transaction log. The transaction log is backed by a Pulsar topic. After the transaction coordinator crashes, it can restore the transaction metadata from the transaction log."),(0,o.kt)("h2",{id:"transaction-id"},"Transaction ID"),(0,o.kt)("p",null,"The transaction ID (TxnID) identifies a unique transaction in Pulsar. The transaction ID is 128-bit. The highest 16 bits are reserved for the ID of the transaction coordinator, and the remaining bits are used for monotonically increasing numbers in each transaction coordinator. It is easy to locate the transaction crash with the TxnID."),(0,o.kt)("h2",{id:"transaction-buffer"},"Transaction buffer"),(0,o.kt)("p",null,"Messages produced within a transaction are stored in the transaction buffer. The messages in transaction buffer are not materialized (visible) to consumers until the transactions are committed. The messages in the transaction buffer are discarded when the transactions are aborted. "),(0,o.kt)("h2",{id:"pending-acknowledge-state"},"Pending acknowledge state"),(0,o.kt)("p",null,"Message acknowledges within a transaction are maintained by the pending acknowledge state before the transaction completes. If a message is in the pending acknowledge state, the message cannot be acknowledged by other transactions until the message is removed from the pending acknowledge state."),(0,o.kt)("p",null,"The pending acknowledge state is persisted to the pending acknowledge log. The pending acknowledge log is backed by a Pulsar topic. A new broker can restore the state from the pending acknowledge log to ensure the acknowledgement is not lost."))}p.isMDXComponent=!0}}]);